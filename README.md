## 如何设计秒杀系统

本文版权归 @海外兔 所有

设计秒杀系统是国内系统设计面试的高频题，学习设计秒杀系统之前，你需要了解如何设计一个基础的电商系统，秒杀系统只是在电商系统上增加了一些特定条件。现在的电商系统功能繁多，除了最基本的购买商品功能，还有物流跟踪，订单管理，社区交互等功能，不过面试中以及本文主要关注的是购买商品功能，购买流程如下：

![流程]()

1. 客户从客户端下单
2. 如果下单成功则进入支付阶段，否则返回购买失败
3.   进入支付阶段后，如果在一定时间内支付成功则返回购买成功，否则返回购买失败


### 从 0 到 1000
想象你自己从零搭建一个电商平台，一开始平台里的商品种类以及日订单量都较少：

| 类别        | 数量 |
| -----------| ----------- |
| 商品种类    | 100 款        |
| 日订单量    | 1000 件         |

根据这些信息，我们可以设计架构 1（下图）：

![架构1](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%9E%B6%E6%9E%841.svg?token=ADNLI5SO66WBSXLCWSQMR5TA32QKI)

1. 客户端发送下单请求给服务端
2. 服务端查询数据库
    - 若该商品库存大于零，将库存减一并且返回下单成功
    - 若该商品库存等于零的话，返回下单失败

架构 1 简单直观，它忽略了系统可用性以及可扩展性，但在日订单量少，不会出现多位客户对同一件商品同时下单的情况下，它很好地完成了我们需要的功能。

### 从 1000 到 100万
经过一段时间后，你的电商平台日订单量飙升到 100 万件，而且在高峰期，例如晚饭后，睡觉前的订单量会特别多：

| 类别        | 数量 |
| -----------| ----------- |
| 商品种类    | 1 万款        |
| 日订单量    | 100 万件         |

这是一个好的消息，不过同时你发现了一个问题，某些商品的成功下单量要大于库存量，也就是说出现了商品超卖的情况。这可是个严重的问题，因为没办法及时交货给客户对电商平台的信誉有极大影响。仔细分析架构 1 后，我们发现了问题的根源：当商品库存只剩下 1 件而有多位客户同时下单的时候，每个下单请求在查询的时候都发现库存大于零，并且将库存减 1 返回下单成功。下图中，在库存只有 1 件的时候，两个请求却都返回下单成功。

![并发安全](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8.svg?token=ADNLI5XY4KF7K4BDTWFAN43A32QIG)


幸运的是，我们知道大部分并发问题都可以通过锁机制或者队列服务来解决：

#### 锁机制

##### 悲观锁

我们可以观察到，超卖问题的原因在于事务查询和更新库区期间，库存已经被其他事务修改了。在学习悲观锁之前，我们先了解下什么是两阶段加锁，两阶段加锁是一个典型的悲观锁策略：

> 两阶段加锁方法类似，当锁的强制性更高。多个事务可以同时读取同一对象，当只要出现任何写操作（包括修改或删除），则必须加锁以独占访问。---《数据密集型应用系统设计》

我们的电商系统中可以应用两阶段加锁，由于下单请求涉及到修改库存，所以先使用排他锁将它锁定，大部分关系型数据库都提供这种功能（在 MySQL 和 PostgresSQL 里面的语法是 SELECT ... FOR 下UPDATE）。流程如下图：

![悲观锁](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%82%B2%E8%A7%82%E9%94%81.svg?token=ADNLI5QWRBA4IMXXNJVL5XTA32QJI)

1. 蓝色请求先获取排他锁，查询和更新库存，在此期间黑色请求等待获取排他锁。
2. 蓝色请求更新库存后释放排他锁，返回下单成功
3.  黑色请求获取排他锁，发现库存为 0，释放排他锁，返回下单失败

我们可以看到悲观锁成功解决了商品超卖问题，不过它的缺点也比较明显：1）处理性能不高，当一件商品当有多位客户同时下单的时候，每个请求需要等待获取排他锁，也就是较长时间才知道是否下单成功。2）容易发生死锁：在实际工程中，下单操作不只涉及了库存修改，还可能涉及其他业务功能，由于悲观锁下每个请求都轮流持有锁，这时候应用层的代码处理不好的话会更容易发生死锁。

##### 乐观锁

和悲观锁不同，乐观锁策略下事务会记录下查询时的版本号，当事务准备更新库存的时候，如果此时的版本号与查询时的版本号不同，则代表库存被其他事务修改了，这时候就会回滚事务，流程如下图：

![乐观锁](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E4%B9%90%E8%A7%82%E9%94%81.svg?token=ADNLI5RJ6CWPSSPN4M6LZ33A32QFK)

1. 蓝色请求与黑色请求查询库存，并记录库存版本号
2. 蓝色请求先更新库存为 0，返回下单成功
3.  黑色请求更新前发现版本与之前版本号不同，回归事务，返回下单失败

乐观锁因为并不需要等待锁，所以在事务竞争较少的情况下比悲观锁有更好的性能，缺点是事务竞争较多的情况下，由于经常需要回滚事务，所以性能较差。

##### 分布式锁
分布式锁在服务端以及数据库之间加上分布式组件来保证请求的并发安全，国内较常使用 Redis 或者 ZooKeeper。和悲观锁类似，每个请求需要先从组件中获取分布式锁之后才可以继续执行。流程如下图：

![分布式锁](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.svg?token=ADNLI5WSJXHZD3MX4HWF2L3A32QHE)

1. 蓝色请求先获取分布式锁，查询和更新库存，在此期间黑色请求等待获取分布式锁
2. 蓝色请求更新库存后释放分布式锁，返回下单成功
3.  黑色请求获取分布式锁，查询库存，发现库存为 0，释放分布式锁，返回下单失败

分布式锁的优点是将功能进行分离，分布式组件负责解决并发安全的问题，数据库负责数据存储。不过缺点在于 1）分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。2）由于引入了新的组件，要考虑分布式组件的可靠性，以及崩溃之后的恢复机制。

##### 消息队列
另一个直观的解决方法就是使用消息队列，确保每个商品每个时刻只有一个请求，流程如下图：

![消息队列](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.svg?token=ADNLI5QIVJB5TUS2QHSTCH3A32QMK)

1. 蓝色请求进入队列，黑色请求进入队列，数据库订阅下单请求
2. 数据库处理蓝色请求，蓝色请求查询和更新库存，返回下单成功
3.  数据库处理黑色请求，查询库存，发现库存为 0，返回下单失败

消息队列的优点对业务进行了解耦，除了数据库之外，其他对下单请求感兴趣的业务系统，例如数据分析，日志记录等都可以订阅下单请求的消息。缺点在于 1）因为消息队列可能会崩溃，消息发送也可能失败，所以要考虑消息只消费一次，不会因为重复消费导致重复下单。2）由于引入了新的组件，要考虑消息队列的可靠性，以及崩溃之后的恢复机制。

对比两个方案的优缺点之后，队列服务更适合我们的电商系统，架构升级后，架构 2 如下：

![架构2](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%9E%B6%E6%9E%842.svg?token=ADNLI5X7TM5WAC4FF53EOGLA32QK4)

1. 客户端发送下单请求给服务端
2. 服务端将请求发送到消息队列
3. 数据库每次从消息队列取出请求
    - 若该商品库存大于零，将库存减一
    - 若该商品库存等于零的话，不做操作
4. 服务端根据消息队列里的消息状态返回下单结果

#### 从电商系统到秒杀系统
秒杀系统和电商系统有两个核心区别：
1. 即使双十一也有极大的流量，但是双十一的商品种类很多，流量会分布到不同的商品中。而秒杀系统中，商品的种类和库存都比较少，导致大部分流量集中在少量商品中。
2. 秒杀系统由于商品稀缺，价值高。同一位客户可能会对同一商品多次提交下单请求，而且恶意刷单的请求比较多，所以系统接收到的无效请求及非法请求较多。

架构 2 有三个潜在问题：

1. 当一款商品库存只有 10 件却有 1 万名用户下单的时候，只有前 10 名客户可以下单成功，其他用户都浪费时间在队列等待以及无意义地查询库存，既牺牲了用户体验也增加了消息队列以及数据库的压力。
2. 由于库存过少，有大量的请求（例如非法用户的请求，超过秒杀活动开始一定时间的请求）其实是没有机会抢到商品的，所以没有必要到达服务器，更不用说数据库了。
3. 大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。

针对这三个问题我们可以考虑两个方案，流量控制资源隔离

##### 流量限制

第三个问题相对简单，可以将秒杀页面缓存到 CDN，另外两个问题可以通过在服务器前面增加限流器来解决，如果商品的库存是 10 件的话，只要限流器接收到 10 * k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。这样无论有多少个下单请求，最终到达服务器的单个商品请求数量都不超过 10 * k。实际工程中，因为有客户可能出现支付超时或者多次下单的情况，这时候该订单会释放库存，同时通知限流器可以接受新的请求，也可以使用常见的限流算法来实现动态限流。在架构设计中，限流器可以和负载均衡，安全验证配合使用，这里的安全验证包括了前端的验证答题，秒杀接口动态生成以及防止重复点击按钮等机制。

![流量限制](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%B5%81%E9%87%8F%E9%99%90%E5%88%B6.svg?token=ADNLI5WI2JOK2RCDIGUYSR3A32QUO)


##### 热门资源隔离
既然大部分流量集中在少量商品中，我们能不能针对这些商品进行特殊处理呢？这样既可以防止秒杀活动影响其他业务功能，也可以针对热门商品进行资源分配，答案是可以的，首先我们需要识别出热门商品，这里有两种常见的方法：

1. 包括京东在内的一些电商平台，客户在参加秒杀活动之前需要先进行预约，只有预约过的客户才能参考秒杀活动。这样系统可以提早识别热门商品以及进行流量预估。
2. 通过实时数据分析系统在秒杀活动前统计出现在较多客户浏览的热门商品，针对预估结果进行资源分配。

识别出热门商品之后，我们可以将热门商品的资源进行隔离，并且设置独立的策略，例如 1）使用特殊的限流器（随机丢弃请求）2）使用单独的数据库，并对每个热门商品库存进行分表，这样可以将修改库存的压力分摊到多个数据库中。

![资源隔离](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB.svg?token=ADNLI5SQJVMP2I727U7IRRDA32QM4)


根据以上两个方案，我们可以设计出最后的架构 3：

![架构3](https://raw.githubusercontent.com/resumejob/How-to-design-a-spike-system/main/imgs/%E6%9E%B6%E6%9E%843.svg?token=ADNLI5WS2Y3YKZ3IPJIXHRTA32QL2)

1. 客户端从 CDN 获取到秒杀静态页面
2. 客户端发送下单请求给网关
3. 在网关或者服务器前进行流量控制以及负载均衡等策略
4. 服务端将请求发送到消息队列
5. 数据库每次从消息队列取出请求
    - 若该商品库存大于零，将库存减一
    - 若该商品库存等于零的话，不做操作
6. 服务端根据消息队列里的消息状态返回下单结果


#### 总结
总的来说，设计秒杀系统的关键在于

1. 合理使用消息队列，既可以解决并发安全问题，也可以进行业务解耦
2. 前后端的流量限制，将大部分的流量拦在服务器之前
3. 热门资源隔离，针对热门商品进行独立处理以及资源分配


### 面试中可能出现的问题

##### 什么时候扣除库存，客户支付成功后再扣除库存可以吗？
应该在下单请求成功的时候扣除库存，若客户在 K 分钟内没有支付成功的话，该订单取消并释放库存。如果在客户支付成功的时候再扣除库存，会出现下单请求成功数量大于库存的情况。

##### 对热门商品进行分表之后可能导致某个分表库存为零，但其他分表还有库存，如何解决这个问题？

- 如果当前分表没有库存的话，到其他分表进行重试，缺点是会放大流量。
- 通过路由组件记录每个分表的库存情况，将下单请求引导到有库存的分表中。
- 使用分布式缓存记录商品每个分表的库存情况，并且每次下单完成后进行更新，缺点是可能出现缓存和数据库不一致的问题。


##### 客户下单后可能支付超时并释放库存，这时候有哪些要注意的？

1. 如果是热门商品，这个增加数量的操作需要平均分配到所有的库上面，同时如果有重试状态的记录（上面提到过），需要清理
2. 前端页面要能即时刷新，确保后续的用户能继续抢
3. 限流器的逻辑需要是动态的，因为商品数量会变化，因此必须要有一个地方能动态查询商品的数量


##### 消息队列方案有什么潜在问题吗？
秒杀系统下，可能 80% 的流量都指向同一个热门商品，那么这个分区会特别大，影响两个方面 1）消息队列本身的稳定性，吞吐量受单个分区限制。2）受到单个消费者消费能力的限制，即使消息队列每秒可以处理大量消息，但是单机数据库每秒处理的数量有限。

解决方案：

- 压力测试：在前期压力测试的时候，模拟流量极端分布的情况，确保架构能够支持。
- 资源隔离：对热点商品使用独立的消息队列，配置更好的磁盘以及更多的分区。
- 合并下单请求：将多个下单请求合并层一个请求，再交给数据库处理。不过在实际工程中，下单业务可能比较复杂，不单包含扣减库存。所以合并逻辑会极大影响后续业务的可扩展性, 甚至可能无法合并下单请求。
- 合并事务：将多个事务合并成一个事务执行，这样能有效减少数据库压力，缺点是逻辑会比较复杂，而且同样可能无法合并，这就会导致所有订单失败，影响比较大。

##### 消息队列如何保证高可用以及高扩展性？
请参考：https://cloud.tencent.com/product/tdmq

##### 消息队列怎么保证消息有且仅生效一次（Exactly Once）?
- 为了保证最少一次生效, 消费者需要下单成功后才能返回确认 ACK，否则有可能会丢失消息
- 为了防止消息重复消费的问题，需要使下单逻辑变为幂等操作，常见的解决方案是保证下单请求有全局唯一的 ID，并且在消息队列中对 ID 进行持久化，在发送给消费者之前先检查 ID 是否已经消费过。要注意，要注意应用层或者中间层的重试机制不会修改这个全局唯一的 ID，不然重试机制会导致消息队列误以为该消息没有消费过。


##### 如何正确地实现分布式锁
了解 SETNX 的局限性以及 RedLock 的基本原理，具体请参考 https://redis.io/topics/distlock

##### 分布式锁和数据库悲观锁相比有什么优势？有什么共同的缺点？

- 优点：加锁的操作不依赖数据库，降低数据库资源冲突的概率和压力。
- 共同缺点：可扩展性差，对于单个商品都是串行操作，假如每个订单执行要 100ms，每秒只能执行 10 个对应的订单，会出现大量请求阻塞的情况。

##### 如何保证缓存和数据库的一致性
请参考：https://www.pixelstech.net/article/1562504974-Consistency-between-Redis-Cache-and-SQL-Database

##### 如果电商系统流量过大，如何进行降级服务？

- 暂停非核心业务，例如淘宝在双十一会暂时关闭退款功能。
- 拒绝服务，当系统压力到达一个阈值的的时候，随机丢弃部分秒杀请求。
- 注意组件中重试次数的设置，需要将重试次数降低甚至设置为0，否则容易造成雪崩效应，系统陷入负反馈循环，无法正常恢复。

##### 我们已经在前面做了一定程度的限流，此时仍然出现流量过大，我们需要在架构的哪一部分做降级？

- 限流器配置错误：限流器的错误配置容易导致流量超过预期，例如运营人员配置的可预定上限过大，导致实际能参与的用户过多，此时整个链路的流量都会存在问题，需要在限流器部分强制降级。
- 前端限流失败：客户请求过多且前端限流失败，此时服务器流量较大，一般可以自动扩容来解决。

##### 怎么测试你的方案，使用最小的资源实现一个稳定的秒杀系统？
需要分析系统可能出现的瓶颈，并提出优化手段。

##### 上面的方案有哪些是需要人工运营的，有没有办法将它自动化？
一般来讲主要考核资源隔离，预订逻辑，分库分表，自动化测试等知识点

##### 你的方案还有哪些可以优化的地方（有什么缺点）？
首先需要了解不同方案的优缺点，例如乐观锁与悲观锁的优缺点，锁机制与消息队列的优缺点。根据不同的业务场景，流量预估以及读写比例调整为合适的方案，实际工程中最好的方案往往是混合方案，根据不同的业务情况进行方案执行。
